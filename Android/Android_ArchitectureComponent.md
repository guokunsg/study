# Android architecture components
https://developer.android.com/topic/libraries/architecture/
# Lifecycle
* Lifecycle
    - a class that holds the information about the lifecycle state of a component (like an activity or a fragment) and allows other objects to observe this state.
    - A class can monitor the component's lifecycle status by adding annotations to its methods.
    - State and events
        [INITIALIZED] -(ON_CREATE)-> [CREATED] -(ON_START)-> [STARTED] -(ON_RESUME)-> [RESUMED]
        [DESTROYED]  <-(ON_DESTROY)- [CREATED] <-(ON_STOP)-  [STARTED] <-(ON_PAUSE)-  [RESUMED]
    - A class can monitor the component's lifecycle status by adding annotations to its methods.
        public class MyObserver implements LifecycleObserver
            @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
            public void connectListener()
* LifecycleOwner
    - LifecycleOwner is a single method interface that denotes that the class has a Lifecycle.
    - one method getLifecycle(), which must be implemented by the class
# LiveData
* LiveData is an observable data holder class
    - LiveData considers an observer in an active state if its lifecycle is in the STARTED or RESUMED state.
    - You can register an observer paired with an object that implements the LifecycleOwner interface
    - Make sure to store LiveData objects that update the UI in ViewModel objects not Activity or Fragment
        public class NameViewModel extends ViewModel
            private MutableLiveData<String> mCurrentName;
            public MutableLiveData<String> getCurrentName()
                if (mCurrentName == null) 
                    mCurrentName = new MutableLiveData<String>();
                return mCurrentName;
    - In most cases, an app componentâ€™s onCreate() method is the right place to begin observing a LiveData object
        public class NameActivity extends AppCompatActivity
            private NameViewModel mModel;
            @Override
            protected void onCreate(Bundle savedInstanceState)
                mModel = ViewModelProviders.of(this).get(NameViewModel.class); // Get the ViewModel.
                final Observer<String> nameObserver = new Observer<String>()
                    @Override public void onChanged(@Nullable final String newName)
                        mNameTextView.setText(newName); // Update the UI, in this case, a TextView.
                // Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.
                mModel.getCurrentName().observe(this, nameObserver);
    - Update LiveData objects: setValue(T) and postValue(T)
        mModel.getCurrentName().setValue(anotherName);
    - Extend LiveData
        public class StockLiveData extends LiveData<BigDecimal>
            // called when there is an active observer. Need to start observing data updates from this method.
            @Override protected void onActive()
            // called when there is no active observers. Can stop data updating
            @Override protected void onInactive() {
            // Need to setValue(T) to update the value of the LiveData instance and notifies any active observers about the change.
# ViewModel
* Designed to store and manage UI-related data in a lifecycle conscious way. 
* allows data to survive configuration changes such as screen rotations.
* A ViewModel must never reference a view, Lifecycle, or any class that may hold a reference to the activity context.
* ViewModel remains in memory until the Lifecycle it's scoped to goes away permanently
* Fragments can share a ViewModel using their activity scope to handle the communication    
    getActivity() to create ViewModelProvider, fragments receive the same SharedViewModel instance, which is scoped to the activity.
* Replacing Loaders with ViewModel and Room

# WorkManager
* WorkManager is intended for tasks that require a guarantee that the system will run them even if the app exits
* Not intended for in-process background work that can safely be terminated if the app process goes away; use ThreadPools for that.
* Components:
    - Worker: specifies what task you need to perform
    - WorkRequest: represents an individual task; autogenerated unique ID;
    - WorkManager: enqueues and manages the work requests.
    - WorkStatus: contains information about a particular task.
    - Constraints: specify constraints on when the task should run.
    public class CompressWorker extends Worker
        @Override public Worker.Result doWork()
            ... return Result.SUCCESS; // RETRY to retry later; FAILURE for error
    OneTimeWorkRequest workRequest = new OneTimeWorkRequest.Builder(CompressWorker.class)
        .setConstraints(myConstraints).build(); 
    WorkManager.getInstance().enqueue(workRequest);
    WorkManager.getInstance().getStatusById(workRequest.getId())
        .observe(lifecycleOwner, workStatus -> { if (workStatus.getState().isFinished()) ...  }) // Observe the result
    Constraints myConstraints = new Constraints.Builder() // Can set constraint before request build
        .setRequiresDeviceIdle(true).setRequiresCharging(true).build();   
    WorkManager.getInstance().cancelWorkById(workRequest.getId()); // Cancel
    PeriodicWorkRequest request = new PeriodicWorkRequest.Builder(
        PhotoCheckWorker.class, 12, TimeUnit.HOURS).build();
    WorkManager.getInstance() // Chained tasks. WorkManager.beginWith() returns WorkContinuation object;
        .beginWith(workA).then(workB).then(workC).enqueue();
    WorkContinuation chain3 = WorkContinuation.combine(chain1, chain2).then(workE); // Can combine WorkContinuation chain
# Data binding library
* Bind UI components in your layouts to data sources in your app using a declarative format rather than programmatically.
    <Layout>
        <data><variable name="user" type="com.databinding.User" /></data>
        <TextView android:text="@{viewmodel.userName}" />
    </Layout>
    ViewDataBinding binding = DataBindingUtil.inflate(inflater,R.layout.fragment_blank, container, false); binding.getRoot();
* Build environment: build.gradle: android { ... dataBinding { enabled = true } }

# ViewModels and LiveData: Patterns + AntiPatterns
https://medium.com/google-developers/viewmodels-and-livedata-patterns-antipatterns-21efaef74a54
* Don't let ViewModels (and Presenters) know about Android framework classes
* Keep the logic in Activities and Fragments to a minimum
* Avoid references to Views in ViewModels. May lead to memory leak
* Instead of pushing data to the UI, let the UI observe changes to it
* A good idea to have a data repo, completely unaware of the presentation layer. 
    Most app has resources: Remote, Local, In-memory
* Expose information about the state of your data using a wrapper or another LiveData
    return LiveData<MyDataState> to include the data status, eg: loading, error
* Design events as part of the state. 
    Some data should be consumed only once, like Snackbar message, a navigation event or a dialog trigger.
    A solution:
    Event<Data> // A wrapper for data that is exposed via a LiveData that represents an event
        private boolean hasBeenHandled = false
        private Data data; // Set data in constructor
        Data getContentIfNotHandled()
            if (hasBeenHandled) return null
            hasBeenHandled = true; return data;
        Data peek() // Returns the content, even if it's already been handled
            return data
* ViewModel may be leaked if data layer holds a reference to it. 
    ViewModel observes data repo as LiveData: LiveData<Repo> repo = Transformations.switchMap(repoIdLiveData, repoId -> {...})
* Can extend LiveData to start data listening: 
    onActive() { start listening on some data}
    onInactive() { stop listening }

# Room
* 3 components:
    - Database: Contains the database holder and serves as the main access point for the underlying connection to the app's persisted, relational data
    - DAO: Contains the methods used for accessing the database
    - Entity: Represents a table within the database
* Sample: 
    @Entity public class User
        @PrimaryKey private int uid;
        @ColumnInfo(name="first_name") private String firstName;
    @DAO public interface UserDao
        @Query("SELECT * FROM user) List<User> getAll();
        @Query("SELECT * FROM user WHERE uid IN (:userIds)") List<User> loadAllByIds(int[] userIds);
        @Insert void insertAll(User... users);
        @Delete void delete(User user);
    @Database(entities={User.class}, version = 1)
    public abstract class AppDatabase extends RoomDatabase
        abstract UserDao userDao();
    AppDatabase db = Room.databaseBuilder(context, AppDatabase.class, "database-name").build();

# Dagger
* Dependency provider: 
    Classes annotated with @Module are responsible for providing objects which can be injected. 
    Such classes define methods annotated with @Provides. 
    The returned objects from these methods are available for dependency injection.
* Dependency consumer: 
    The @Inject annotation is used to define a dependency.
* Connecting consumer and producer: 
    A @Component annotated interface defines the connection between the provider of objects (modules) and the objects which express a dependency. 
    The class for this connection is generated by the Dagger.
* DaggerComponent.builder() // Auto generate Dagger+Component
    .mainModule(new MainModule(this)) // Set the module object with additional parameter
    .build().inject(this); // @Inject attributes will be provided by MainModule

# Google MVP samples
https://github.com/googlesamples/android-architecture
* todo-mvp
    - Model: Operates data. Data repository
    - Presenter: Hosts business logic associated with a particular feature and the corresponding view handles the UI
    - View: Contains almost no logic; converts the presenter's commands to UI actions, listens for user actions and then passes to presenter
    - Activity creates View and Presenter. Fragment implements View
    - Structure
    interface XXXContract // Just hold view and presenter, defines the connection
        interface View extends BaseView<Presenter>
        interface Presenter extends BasePresenter
    interface BaseView<T>
        void setPresenter(T presenter)
    interface BasePresenter
        void start(); // Just do initialization
* todo-mvp-clean
    - Clean architecture
    - MVP: Model View Presenter pattern from the base sample.
    - Domain: Holds all business logic. The domain layer starts with classes named use cases or interactors used by the application presenters. These use cases represent all the possible actions a developer can perform from the presentation layer.
    - Repository: Repository pattern from the base sample.
    - Use cases define the operations that the app needs. Good for reuse and maintenance. Used Command pattern
    - Structure
    abstract class UseCase<Q extends UseCase.RequestValue, P extends UseCase.ResponseValue>
        executeUseCase(RequestValue q)
        interface UseCaseCallback<R>
            void onSuccess(R response)
            void onError(e)
    interface UseCaseScheduler
        void execute(Runnable r)
         <V extends UseCase.ResponseValue> void notifyResponse(final V response, final UseCase.UseCaseCallback<V> useCaseCallback)
         <V extends UseCase.ResponseValue> void onError( final UseCase.UseCaseCallback<V> useCaseCallback)
    // A scheduler implementation, using thread pool to execute use cases and Handler to post notifications in UI thread
    class UseCaseThreadPoolScheduler implements UseCaseScheduler 
    // Presenter operates the tasks and display the result
* todo-mvp-dagger
    - Structure
    class TodoApplication extends Application
        mRepositoryComponent = DaggerTasksRepositoryComponent.builder().applicationModule(
                new ApplicationModule((getApplicationContext()))).build();
    @Module class ApplicationModule
        @Provides Context provideContext() // Provides application context
    @Singleton @Component(modules = {TasksRepositoryModule.class, ApplicationModule.class}) 
    public interface TasksRepositoryComponent // A Model component
        TasksRepository getTasksRepository()
    // Some Model classes
    @Module abstract class TasksRepositoryModule 
        @Singleton @Binds @Local abstract TasksDataSource provideTasksLocalDataSource(TasksLocalDataSource dataSource)
        @Singleton @Binds @Remote abstract TasksDataSource provideTasksRemoteDataSource(TasksRemoteDataSource dataSource)
    @Singleton public class TasksRepository implements TasksDataSource 
        @Inject TasksRepository(@Remote TasksDataSource tasksRemoteDataSource, @Local TasksDataSource tasksLocalDataSource) // Injection
    @Singleton public class TasksLocalDataSource implements TasksDataSource 
        @Inject public TasksLocalDataSource(@NonNull Context context) // Injection
* todo-mvp-rxjava
    - Structure
    interface BasePresenter
        void subscribe()
        void unsubscribe()
    class Presenter
        private CompositeSubscription mSubscriptions
            @Override public void subscribe() 
                if (!isNewTask() && mIsDataMissing) 
                    mSubscriptions.add(mTasksRepository.getTask(mTaskId)
                        .subscribeOn(mSchedulerProvider.computation()).observeOn(mSchedulerProvider.ui())
                        .subscribe(onNextTask, onErrorTask);
            @Override public void unsubscribe() 
                mSubscriptions.clear();
    // Fragment onResume subscribe, onPause unsubscribe
    class TasksRepository // Data
        @Override public Observable<Task> getTask(String taskId)
            if (cachedTask != null) return Observable.just(cachedTask)
            Observable<Task> localTask = ...
            Observable<Task> remoteTask = ...
            return Observable.concat(localTask, remoteTask).first();
* todo-mvvm-live
    View: Use data binding
    ViewModel: Use ObservableXXX for auto data binding














